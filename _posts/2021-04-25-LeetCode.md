---
layout: post
title: "LeetCode"
date: 2021-04-25
description: "LeetCodes刷题汇总"
tags: 算法
---

## 二叉树

### 124. 二叉树的最大路径和

-- C++
```
int getMax(TreeNode* root, int &maxSum){
    if(root==nullptr){
        return 0;
    }
    int left=max(0,getMax(root->left, maxSum));
    int right=max(0,getMax(root->right, maxSum));
    maxSum = max(maxSum, left+right+root->val);
    return root->val+max(left,right);
}

int maxPathSum(TreeNode* root) {
    int maxSum = INT_MIN;
    getMax(root, maxSum);
    return maxSum;
}
```

-- Python
```
class Solution:
    def __init__(self):
        self.maxSum = float("-inf")

    def maxPathSum(self, root: TreeNode) -> int:
        def getMax(self, node: TreeNode):
            if not node:
                return 0
            
            left = max(0, getMax(self, node.left))
            right = max(0, getMax(self, node.right))
            lr = left + right + node.val
            self.maxSum = max(self.maxSum, lr)
            return node.val + max(left, right)

        getMax(self, root)
        return self.maxSum
```

### 105. 从前序与中序遍历序列构造二叉树

-- C++
```
TreeNode* recurrent(vector<int>& preorder,int preL,int preR,vector<int>& inorder,int inL,int inR){
    if(preR<preL||inR<inL){
        return nullptr;
    }
    TreeNode* curRoot = new TreeNode(preorder[preL]);
    int idx = inL;
    while(idx <= inR){
        if(inorder[idx]==preorder[preL]){
            break;
        }
        idx++;
    }
    curRoot->left = recurrent(preorder,preL+1,preL+idx-inL,inorder,inL,idx-1);
    curRoot->right = recurrent(preorder,preR-(inR-idx-1),preR,inorder,idx+1,inR);
    return curRoot;
}
TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
    int preLen = preorder.size(), inLen = inorder.size();
    return recurrent(preorder,0,preLen-1,inorder,0,inLen-1);
}
```
